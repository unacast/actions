(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = global || self, factory(global.circleciApi = {}));
}(this, function (exports) { 'use strict';

  var API_BASE = "https://circleci.com/api/v1.1";
  var API_ME = "/me";
  var API_PROJECT = "/project";
  var API_ALL_PROJECTS = "/projects";
  var API_RECENT_BUILDS = "/recent-builds";
  var API_USER = "/user";
  (function (GitType) {
      GitType["GITHUB"] = "github";
      GitType["BITBUCKET"] = "bitbucket";
  })(exports.GitType || (exports.GitType = {}));
  /**
   * Create a base project url
   * @param type - Type of version control, default "github"
   * @param owner - Owner of the repository
   * @param repo - Target repository
   */
  function createVcsUrl(_a) {
      var _b = _a.type, type = _b === void 0 ? exports.GitType.GITHUB : _b, owner = _a.owner, repo = _a.repo;
      return API_PROJECT + "/" + type + "/" + owner + "/" + repo;
  }
  (function (BuildAction) {
      BuildAction["RETRY"] = "retry";
      BuildAction["CANCEL"] = "cancel";
  })(exports.BuildAction || (exports.BuildAction = {}));

  /*! *****************************************************************************
  Copyright (c) Microsoft Corporation. All rights reserved.
  Licensed under the Apache License, Version 2.0 (the "License"); you may not use
  this file except in compliance with the License. You may obtain a copy of the
  License at http://www.apache.org/licenses/LICENSE-2.0

  THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  MERCHANTABLITY OR NON-INFRINGEMENT.

  See the Apache Version 2.0 License for specific language governing permissions
  and limitations under the License.
  ***************************************************************************** */

  var __assign = function() {
      __assign = Object.assign || function __assign(t) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
              s = arguments[i];
              for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
          }
          return t;
      };
      return __assign.apply(this, arguments);
  };

  function __rest(s, e) {
      var t = {};
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
          t[p] = s[p];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
              t[p[i]] = s[p[i]];
      return t;
  }

  function __awaiter(thisArg, _arguments, P, generator) {
      return new (P || (P = Promise))(function (resolve, reject) {
          function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
          function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
          function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
  }

  function __generator(thisArg, body) {
      var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
      function verb(n) { return function (v) { return step([n, v]); }; }
      function step(op) {
          if (f) throw new TypeError("Generator is already executing.");
          while (_) try {
              if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
              if (y = 0, t) op = [op[0] & 2, t.value];
              switch (op[0]) {
                  case 0: case 1: t = op; break;
                  case 4: _.label++; return { value: op[1], done: false };
                  case 5: _.label++; y = op[1]; op = [0]; continue;
                  case 7: op = _.ops.pop(); _.trys.pop(); continue;
                  default:
                      if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                      if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                      if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                      if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                      if (t[2]) _.ops.pop();
                      _.trys.pop(); continue;
              }
              op = body.call(thisArg, _);
          } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
          if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
      }
  }

  var bind = function bind(fn, thisArg) {
    return function wrap() {
      var args = new Array(arguments.length);
      for (var i = 0; i < args.length; i++) {
        args[i] = arguments[i];
      }
      return fn.apply(thisArg, args);
    };
  };

  /*!
   * Determine if an object is a Buffer
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   */

  var isBuffer = function isBuffer (obj) {
    return obj != null && obj.constructor != null &&
      typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
  };

  /*global toString:true*/

  // utils is a library of generic helper functions non-specific to axios

  var toString = Object.prototype.toString;

  /**
   * Determine if a value is an Array
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is an Array, otherwise false
   */
  function isArray(val) {
    return toString.call(val) === '[object Array]';
  }

  /**
   * Determine if a value is an ArrayBuffer
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is an ArrayBuffer, otherwise false
   */
  function isArrayBuffer(val) {
    return toString.call(val) === '[object ArrayBuffer]';
  }

  /**
   * Determine if a value is a FormData
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is an FormData, otherwise false
   */
  function isFormData(val) {
    return (typeof FormData !== 'undefined') && (val instanceof FormData);
  }

  /**
   * Determine if a value is a view on an ArrayBuffer
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
   */
  function isArrayBufferView(val) {
    var result;
    if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {
      result = ArrayBuffer.isView(val);
    } else {
      result = (val) && (val.buffer) && (val.buffer instanceof ArrayBuffer);
    }
    return result;
  }

  /**
   * Determine if a value is a String
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is a String, otherwise false
   */
  function isString(val) {
    return typeof val === 'string';
  }

  /**
   * Determine if a value is a Number
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is a Number, otherwise false
   */
  function isNumber(val) {
    return typeof val === 'number';
  }

  /**
   * Determine if a value is undefined
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if the value is undefined, otherwise false
   */
  function isUndefined(val) {
    return typeof val === 'undefined';
  }

  /**
   * Determine if a value is an Object
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is an Object, otherwise false
   */
  function isObject(val) {
    return val !== null && typeof val === 'object';
  }

  /**
   * Determine if a value is a Date
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is a Date, otherwise false
   */
  function isDate(val) {
    return toString.call(val) === '[object Date]';
  }

  /**
   * Determine if a value is a File
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is a File, otherwise false
   */
  function isFile(val) {
    return toString.call(val) === '[object File]';
  }

  /**
   * Determine if a value is a Blob
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is a Blob, otherwise false
   */
  function isBlob(val) {
    return toString.call(val) === '[object Blob]';
  }

  /**
   * Determine if a value is a Function
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is a Function, otherwise false
   */
  function isFunction(val) {
    return toString.call(val) === '[object Function]';
  }

  /**
   * Determine if a value is a Stream
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is a Stream, otherwise false
   */
  function isStream(val) {
    return isObject(val) && isFunction(val.pipe);
  }

  /**
   * Determine if a value is a URLSearchParams object
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is a URLSearchParams object, otherwise false
   */
  function isURLSearchParams(val) {
    return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;
  }

  /**
   * Trim excess whitespace off the beginning and end of a string
   *
   * @param {String} str The String to trim
   * @returns {String} The String freed of excess whitespace
   */
  function trim(str) {
    return str.replace(/^\s*/, '').replace(/\s*$/, '');
  }

  /**
   * Determine if we're running in a standard browser environment
   *
   * This allows axios to run in a web worker, and react-native.
   * Both environments support XMLHttpRequest, but not fully standard globals.
   *
   * web workers:
   *  typeof window -> undefined
   *  typeof document -> undefined
   *
   * react-native:
   *  navigator.product -> 'ReactNative'
   * nativescript
   *  navigator.product -> 'NativeScript' or 'NS'
   */
  function isStandardBrowserEnv() {
    if (typeof navigator !== 'undefined' && (navigator.product === 'ReactNative' ||
                                             navigator.product === 'NativeScript' ||
                                             navigator.product === 'NS')) {
      return false;
    }
    return (
      typeof window !== 'undefined' &&
      typeof document !== 'undefined'
    );
  }

  /**
   * Iterate over an Array or an Object invoking a function for each item.
   *
   * If `obj` is an Array callback will be called passing
   * the value, index, and complete array for each item.
   *
   * If 'obj' is an Object callback will be called passing
   * the value, key, and complete object for each property.
   *
   * @param {Object|Array} obj The object to iterate
   * @param {Function} fn The callback to invoke for each item
   */
  function forEach(obj, fn) {
    // Don't bother if no value provided
    if (obj === null || typeof obj === 'undefined') {
      return;
    }

    // Force an array if not already something iterable
    if (typeof obj !== 'object') {
      /*eslint no-param-reassign:0*/
      obj = [obj];
    }

    if (isArray(obj)) {
      // Iterate over array values
      for (var i = 0, l = obj.length; i < l; i++) {
        fn.call(null, obj[i], i, obj);
      }
    } else {
      // Iterate over object keys
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          fn.call(null, obj[key], key, obj);
        }
      }
    }
  }

  /**
   * Accepts varargs expecting each argument to be an object, then
   * immutably merges the properties of each object and returns result.
   *
   * When multiple objects contain the same key the later object in
   * the arguments list will take precedence.
   *
   * Example:
   *
   * ```js
   * var result = merge({foo: 123}, {foo: 456});
   * console.log(result.foo); // outputs 456
   * ```
   *
   * @param {Object} obj1 Object to merge
   * @returns {Object} Result of all merge properties
   */
  function merge(/* obj1, obj2, obj3, ... */) {
    var result = {};
    function assignValue(val, key) {
      if (typeof result[key] === 'object' && typeof val === 'object') {
        result[key] = merge(result[key], val);
      } else {
        result[key] = val;
      }
    }

    for (var i = 0, l = arguments.length; i < l; i++) {
      forEach(arguments[i], assignValue);
    }
    return result;
  }

  /**
   * Function equal to merge with the difference being that no reference
   * to original objects is kept.
   *
   * @see merge
   * @param {Object} obj1 Object to merge
   * @returns {Object} Result of all merge properties
   */
  function deepMerge(/* obj1, obj2, obj3, ... */) {
    var result = {};
    function assignValue(val, key) {
      if (typeof result[key] === 'object' && typeof val === 'object') {
        result[key] = deepMerge(result[key], val);
      } else if (typeof val === 'object') {
        result[key] = deepMerge({}, val);
      } else {
        result[key] = val;
      }
    }

    for (var i = 0, l = arguments.length; i < l; i++) {
      forEach(arguments[i], assignValue);
    }
    return result;
  }

  /**
   * Extends object a by mutably adding to it the properties of object b.
   *
   * @param {Object} a The object to be extended
   * @param {Object} b The object to copy properties from
   * @param {Object} thisArg The object to bind function to
   * @return {Object} The resulting value of object a
   */
  function extend(a, b, thisArg) {
    forEach(b, function assignValue(val, key) {
      if (thisArg && typeof val === 'function') {
        a[key] = bind(val, thisArg);
      } else {
        a[key] = val;
      }
    });
    return a;
  }

  var utils = {
    isArray: isArray,
    isArrayBuffer: isArrayBuffer,
    isBuffer: isBuffer,
    isFormData: isFormData,
    isArrayBufferView: isArrayBufferView,
    isString: isString,
    isNumber: isNumber,
    isObject: isObject,
    isUndefined: isUndefined,
    isDate: isDate,
    isFile: isFile,
    isBlob: isBlob,
    isFunction: isFunction,
    isStream: isStream,
    isURLSearchParams: isURLSearchParams,
    isStandardBrowserEnv: isStandardBrowserEnv,
    forEach: forEach,
    merge: merge,
    deepMerge: deepMerge,
    extend: extend,
    trim: trim
  };

  function encode(val) {
    return encodeURIComponent(val).
      replace(/%40/gi, '@').
      replace(/%3A/gi, ':').
      replace(/%24/g, '$').
      replace(/%2C/gi, ',').
      replace(/%20/g, '+').
      replace(/%5B/gi, '[').
      replace(/%5D/gi, ']');
  }

  /**
   * Build a URL by appending params to the end
   *
   * @param {string} url The base of the url (e.g., http://www.google.com)
   * @param {object} [params] The params to be appended
   * @returns {string} The formatted url
   */
  var buildURL = function buildURL(url, params, paramsSerializer) {
    /*eslint no-param-reassign:0*/
    if (!params) {
      return url;
    }

    var serializedParams;
    if (paramsSerializer) {
      serializedParams = paramsSerializer(params);
    } else if (utils.isURLSearchParams(params)) {
      serializedParams = params.toString();
    } else {
      var parts = [];

      utils.forEach(params, function serialize(val, key) {
        if (val === null || typeof val === 'undefined') {
          return;
        }

        if (utils.isArray(val)) {
          key = key + '[]';
        } else {
          val = [val];
        }

        utils.forEach(val, function parseValue(v) {
          if (utils.isDate(v)) {
            v = v.toISOString();
          } else if (utils.isObject(v)) {
            v = JSON.stringify(v);
          }
          parts.push(encode(key) + '=' + encode(v));
        });
      });

      serializedParams = parts.join('&');
    }

    if (serializedParams) {
      var hashmarkIndex = url.indexOf('#');
      if (hashmarkIndex !== -1) {
        url = url.slice(0, hashmarkIndex);
      }

      url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
    }

    return url;
  };

  function InterceptorManager() {
    this.handlers = [];
  }

  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  InterceptorManager.prototype.use = function use(fulfilled, rejected) {
    this.handlers.push({
      fulfilled: fulfilled,
      rejected: rejected
    });
    return this.handlers.length - 1;
  };

  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   */
  InterceptorManager.prototype.eject = function eject(id) {
    if (this.handlers[id]) {
      this.handlers[id] = null;
    }
  };

  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   */
  InterceptorManager.prototype.forEach = function forEach(fn) {
    utils.forEach(this.handlers, function forEachHandler(h) {
      if (h !== null) {
        fn(h);
      }
    });
  };

  var InterceptorManager_1 = InterceptorManager;

  /**
   * Transform the data for a request or a response
   *
   * @param {Object|String} data The data to be transformed
   * @param {Array} headers The headers for the request or response
   * @param {Array|Function} fns A single function or Array of functions
   * @returns {*} The resulting transformed data
   */
  var transformData = function transformData(data, headers, fns) {
    /*eslint no-param-reassign:0*/
    utils.forEach(fns, function transform(fn) {
      data = fn(data, headers);
    });

    return data;
  };

  var isCancel = function isCancel(value) {
    return !!(value && value.__CANCEL__);
  };

  var global$1 = (typeof global !== "undefined" ? global :
              typeof self !== "undefined" ? self :
              typeof window !== "undefined" ? window : {});

  // shim for using process in browser
  // based off https://github.com/defunctzombie/node-process/blob/master/browser.js

  function defaultSetTimout() {
      throw new Error('setTimeout has not been defined');
  }
  function defaultClearTimeout () {
      throw new Error('clearTimeout has not been defined');
  }
  var cachedSetTimeout = defaultSetTimout;
  var cachedClearTimeout = defaultClearTimeout;
  if (typeof global$1.setTimeout === 'function') {
      cachedSetTimeout = setTimeout;
  }
  if (typeof global$1.clearTimeout === 'function') {
      cachedClearTimeout = clearTimeout;
  }

  function runTimeout(fun) {
      if (cachedSetTimeout === setTimeout) {
          //normal enviroments in sane situations
          return setTimeout(fun, 0);
      }
      // if setTimeout wasn't available but was latter defined
      if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
          cachedSetTimeout = setTimeout;
          return setTimeout(fun, 0);
      }
      try {
          // when when somebody has screwed with setTimeout but no I.E. maddness
          return cachedSetTimeout(fun, 0);
      } catch(e){
          try {
              // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
              return cachedSetTimeout.call(null, fun, 0);
          } catch(e){
              // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
              return cachedSetTimeout.call(this, fun, 0);
          }
      }


  }
  function runClearTimeout(marker) {
      if (cachedClearTimeout === clearTimeout) {
          //normal enviroments in sane situations
          return clearTimeout(marker);
      }
      // if clearTimeout wasn't available but was latter defined
      if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
          cachedClearTimeout = clearTimeout;
          return clearTimeout(marker);
      }
      try {
          // when when somebody has screwed with setTimeout but no I.E. maddness
          return cachedClearTimeout(marker);
      } catch (e){
          try {
              // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
              return cachedClearTimeout.call(null, marker);
          } catch (e){
              // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
              // Some versions of I.E. have different rules for clearTimeout vs setTimeout
              return cachedClearTimeout.call(this, marker);
          }
      }



  }
  var queue = [];
  var draining = false;
  var currentQueue;
  var queueIndex = -1;

  function cleanUpNextTick() {
      if (!draining || !currentQueue) {
          return;
      }
      draining = false;
      if (currentQueue.length) {
          queue = currentQueue.concat(queue);
      } else {
          queueIndex = -1;
      }
      if (queue.length) {
          drainQueue();
      }
  }

  function drainQueue() {
      if (draining) {
          return;
      }
      var timeout = runTimeout(cleanUpNextTick);
      draining = true;

      var len = queue.length;
      while(len) {
          currentQueue = queue;
          queue = [];
          while (++queueIndex < len) {
              if (currentQueue) {
                  currentQueue[queueIndex].run();
              }
          }
          queueIndex = -1;
          len = queue.length;
      }
      currentQueue = null;
      draining = false;
      runClearTimeout(timeout);
  }
  function nextTick(fun) {
      var args = new Array(arguments.length - 1);
      if (arguments.length > 1) {
          for (var i = 1; i < arguments.length; i++) {
              args[i - 1] = arguments[i];
          }
      }
      queue.push(new Item(fun, args));
      if (queue.length === 1 && !draining) {
          runTimeout(drainQueue);
      }
  }
  // v8 likes predictible objects
  function Item(fun, array) {
      this.fun = fun;
      this.array = array;
  }
  Item.prototype.run = function () {
      this.fun.apply(null, this.array);
  };
  var title = 'browser';
  var platform = 'browser';
  var browser = true;
  var env = {};
  var argv = [];
  var version = ''; // empty string to avoid regexp issues
  var versions = {};
  var release = {};
  var config = {};

  function noop() {}

  var on = noop;
  var addListener = noop;
  var once = noop;
  var off = noop;
  var removeListener = noop;
  var removeAllListeners = noop;
  var emit = noop;

  function binding(name) {
      throw new Error('process.binding is not supported');
  }

  function cwd () { return '/' }
  function chdir (dir) {
      throw new Error('process.chdir is not supported');
  }function umask() { return 0; }

  // from https://github.com/kumavis/browser-process-hrtime/blob/master/index.js
  var performance = global$1.performance || {};
  var performanceNow =
    performance.now        ||
    performance.mozNow     ||
    performance.msNow      ||
    performance.oNow       ||
    performance.webkitNow  ||
    function(){ return (new Date()).getTime() };

  // generate timestamp or delta
  // see http://nodejs.org/api/process.html#process_process_hrtime
  function hrtime(previousTimestamp){
    var clocktime = performanceNow.call(performance)*1e-3;
    var seconds = Math.floor(clocktime);
    var nanoseconds = Math.floor((clocktime%1)*1e9);
    if (previousTimestamp) {
      seconds = seconds - previousTimestamp[0];
      nanoseconds = nanoseconds - previousTimestamp[1];
      if (nanoseconds<0) {
        seconds--;
        nanoseconds += 1e9;
      }
    }
    return [seconds,nanoseconds]
  }

  var startTime = new Date();
  function uptime() {
    var currentTime = new Date();
    var dif = currentTime - startTime;
    return dif / 1000;
  }

  var process = {
    nextTick: nextTick,
    title: title,
    browser: browser,
    env: env,
    argv: argv,
    version: version,
    versions: versions,
    on: on,
    addListener: addListener,
    once: once,
    off: off,
    removeListener: removeListener,
    removeAllListeners: removeAllListeners,
    emit: emit,
    binding: binding,
    cwd: cwd,
    chdir: chdir,
    umask: umask,
    hrtime: hrtime,
    platform: platform,
    release: release,
    config: config,
    uptime: uptime
  };

  var normalizeHeaderName = function normalizeHeaderName(headers, normalizedName) {
    utils.forEach(headers, function processHeader(value, name) {
      if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
        headers[normalizedName] = value;
        delete headers[name];
      }
    });
  };

  /**
   * Update an Error with the specified config, error code, and response.
   *
   * @param {Error} error The error to update.
   * @param {Object} config The config.
   * @param {string} [code] The error code (for example, 'ECONNABORTED').
   * @param {Object} [request] The request.
   * @param {Object} [response] The response.
   * @returns {Error} The error.
   */
  var enhanceError = function enhanceError(error, config, code, request, response) {
    error.config = config;
    if (code) {
      error.code = code;
    }

    error.request = request;
    error.response = response;
    error.isAxiosError = true;

    error.toJSON = function() {
      return {
        // Standard
        message: this.message,
        name: this.name,
        // Microsoft
        description: this.description,
        number: this.number,
        // Mozilla
        fileName: this.fileName,
        lineNumber: this.lineNumber,
        columnNumber: this.columnNumber,
        stack: this.stack,
        // Axios
        config: this.config,
        code: this.code
      };
    };
    return error;
  };

  /**
   * Create an Error with the specified message, config, error code, request and response.
   *
   * @param {string} message The error message.
   * @param {Object} config The config.
   * @param {string} [code] The error code (for example, 'ECONNABORTED').
   * @param {Object} [request] The request.
   * @param {Object} [response] The response.
   * @returns {Error} The created error.
   */
  var createError = function createError(message, config, code, request, response) {
    var error = new Error(message);
    return enhanceError(error, config, code, request, response);
  };

  /**
   * Resolve or reject a Promise based on response status.
   *
   * @param {Function} resolve A function that resolves the promise.
   * @param {Function} reject A function that rejects the promise.
   * @param {object} response The response.
   */
  var settle = function settle(resolve, reject, response) {
    var validateStatus = response.config.validateStatus;
    if (!validateStatus || validateStatus(response.status)) {
      resolve(response);
    } else {
      reject(createError(
        'Request failed with status code ' + response.status,
        response.config,
        null,
        response.request,
        response
      ));
    }
  };

  // Headers whose duplicates are ignored by node
  // c.f. https://nodejs.org/api/http.html#http_message_headers
  var ignoreDuplicateOf = [
    'age', 'authorization', 'content-length', 'content-type', 'etag',
    'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',
    'last-modified', 'location', 'max-forwards', 'proxy-authorization',
    'referer', 'retry-after', 'user-agent'
  ];

  /**
   * Parse headers into an object
   *
   * ```
   * Date: Wed, 27 Aug 2014 08:58:49 GMT
   * Content-Type: application/json
   * Connection: keep-alive
   * Transfer-Encoding: chunked
   * ```
   *
   * @param {String} headers Headers needing to be parsed
   * @returns {Object} Headers parsed into an object
   */
  var parseHeaders = function parseHeaders(headers) {
    var parsed = {};
    var key;
    var val;
    var i;

    if (!headers) { return parsed; }

    utils.forEach(headers.split('\n'), function parser(line) {
      i = line.indexOf(':');
      key = utils.trim(line.substr(0, i)).toLowerCase();
      val = utils.trim(line.substr(i + 1));

      if (key) {
        if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
          return;
        }
        if (key === 'set-cookie') {
          parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
        } else {
          parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
        }
      }
    });

    return parsed;
  };

  var isURLSameOrigin = (
    utils.isStandardBrowserEnv() ?

    // Standard browser envs have full support of the APIs needed to test
    // whether the request URL is of the same origin as current location.
      (function standardBrowserEnv() {
        var msie = /(msie|trident)/i.test(navigator.userAgent);
        var urlParsingNode = document.createElement('a');
        var originURL;

        /**
      * Parse a URL to discover it's components
      *
      * @param {String} url The URL to be parsed
      * @returns {Object}
      */
        function resolveURL(url) {
          var href = url;

          if (msie) {
          // IE needs attribute set twice to normalize properties
            urlParsingNode.setAttribute('href', href);
            href = urlParsingNode.href;
          }

          urlParsingNode.setAttribute('href', href);

          // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
          return {
            href: urlParsingNode.href,
            protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
            host: urlParsingNode.host,
            search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
            hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
            hostname: urlParsingNode.hostname,
            port: urlParsingNode.port,
            pathname: (urlParsingNode.pathname.charAt(0) === '/') ?
              urlParsingNode.pathname :
              '/' + urlParsingNode.pathname
          };
        }

        originURL = resolveURL(window.location.href);

        /**
      * Determine if a URL shares the same origin as the current location
      *
      * @param {String} requestURL The URL to test
      * @returns {boolean} True if URL shares the same origin, otherwise false
      */
        return function isURLSameOrigin(requestURL) {
          var parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;
          return (parsed.protocol === originURL.protocol &&
              parsed.host === originURL.host);
        };
      })() :

    // Non standard browser envs (web workers, react-native) lack needed support.
      (function nonStandardBrowserEnv() {
        return function isURLSameOrigin() {
          return true;
        };
      })()
  );

  var cookies = (
    utils.isStandardBrowserEnv() ?

    // Standard browser envs support document.cookie
      (function standardBrowserEnv() {
        return {
          write: function write(name, value, expires, path, domain, secure) {
            var cookie = [];
            cookie.push(name + '=' + encodeURIComponent(value));

            if (utils.isNumber(expires)) {
              cookie.push('expires=' + new Date(expires).toGMTString());
            }

            if (utils.isString(path)) {
              cookie.push('path=' + path);
            }

            if (utils.isString(domain)) {
              cookie.push('domain=' + domain);
            }

            if (secure === true) {
              cookie.push('secure');
            }

            document.cookie = cookie.join('; ');
          },

          read: function read(name) {
            var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
            return (match ? decodeURIComponent(match[3]) : null);
          },

          remove: function remove(name) {
            this.write(name, '', Date.now() - 86400000);
          }
        };
      })() :

    // Non standard browser env (web workers, react-native) lack needed support.
      (function nonStandardBrowserEnv() {
        return {
          write: function write() {},
          read: function read() { return null; },
          remove: function remove() {}
        };
      })()
  );

  var xhr = function xhrAdapter(config) {
    return new Promise(function dispatchXhrRequest(resolve, reject) {
      var requestData = config.data;
      var requestHeaders = config.headers;

      if (utils.isFormData(requestData)) {
        delete requestHeaders['Content-Type']; // Let the browser set it
      }

      var request = new XMLHttpRequest();

      // HTTP basic authentication
      if (config.auth) {
        var username = config.auth.username || '';
        var password = config.auth.password || '';
        requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
      }

      request.open(config.method.toUpperCase(), buildURL(config.url, config.params, config.paramsSerializer), true);

      // Set the request timeout in MS
      request.timeout = config.timeout;

      // Listen for ready state
      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        }

        // The request errored out and we didn't get a response, this will be
        // handled by onerror instead
        // With one exception: request that using file: protocol, most browsers
        // will return status as 0 even though it's a successful request
        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
          return;
        }

        // Prepare the response
        var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
        var responseData = !config.responseType || config.responseType === 'text' ? request.responseText : request.response;
        var response = {
          data: responseData,
          status: request.status,
          statusText: request.statusText,
          headers: responseHeaders,
          config: config,
          request: request
        };

        settle(resolve, reject, response);

        // Clean up request
        request = null;
      };

      // Handle browser request cancellation (as opposed to a manual cancellation)
      request.onabort = function handleAbort() {
        if (!request) {
          return;
        }

        reject(createError('Request aborted', config, 'ECONNABORTED', request));

        // Clean up request
        request = null;
      };

      // Handle low level network errors
      request.onerror = function handleError() {
        // Real errors are hidden from us by the browser
        // onerror should only fire if it's a network error
        reject(createError('Network Error', config, null, request));

        // Clean up request
        request = null;
      };

      // Handle timeout
      request.ontimeout = function handleTimeout() {
        reject(createError('timeout of ' + config.timeout + 'ms exceeded', config, 'ECONNABORTED',
          request));

        // Clean up request
        request = null;
      };

      // Add xsrf header
      // This is only done if running in a standard browser environment.
      // Specifically not if we're in a web worker, or react-native.
      if (utils.isStandardBrowserEnv()) {
        var cookies$1 = cookies;

        // Add xsrf header
        var xsrfValue = (config.withCredentials || isURLSameOrigin(config.url)) && config.xsrfCookieName ?
          cookies$1.read(config.xsrfCookieName) :
          undefined;

        if (xsrfValue) {
          requestHeaders[config.xsrfHeaderName] = xsrfValue;
        }
      }

      // Add headers to the request
      if ('setRequestHeader' in request) {
        utils.forEach(requestHeaders, function setRequestHeader(val, key) {
          if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {
            // Remove Content-Type if data is undefined
            delete requestHeaders[key];
          } else {
            // Otherwise add header to the request
            request.setRequestHeader(key, val);
          }
        });
      }

      // Add withCredentials to request if needed
      if (config.withCredentials) {
        request.withCredentials = true;
      }

      // Add responseType to request if needed
      if (config.responseType) {
        try {
          request.responseType = config.responseType;
        } catch (e) {
          // Expected DOMException thrown by browsers not compatible XMLHttpRequest Level 2.
          // But, this can be suppressed for 'json' type as it can be parsed by default 'transformResponse' function.
          if (config.responseType !== 'json') {
            throw e;
          }
        }
      }

      // Handle progress if needed
      if (typeof config.onDownloadProgress === 'function') {
        request.addEventListener('progress', config.onDownloadProgress);
      }

      // Not all browsers support upload events
      if (typeof config.onUploadProgress === 'function' && request.upload) {
        request.upload.addEventListener('progress', config.onUploadProgress);
      }

      if (config.cancelToken) {
        // Handle cancellation
        config.cancelToken.promise.then(function onCanceled(cancel) {
          if (!request) {
            return;
          }

          request.abort();
          reject(cancel);
          // Clean up request
          request = null;
        });
      }

      if (requestData === undefined) {
        requestData = null;
      }

      // Send the request
      request.send(requestData);
    });
  };

  var DEFAULT_CONTENT_TYPE = {
    'Content-Type': 'application/x-www-form-urlencoded'
  };

  function setContentTypeIfUnset(headers, value) {
    if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {
      headers['Content-Type'] = value;
    }
  }

  function getDefaultAdapter() {
    var adapter;
    // Only Node.JS has a process variable that is of [[Class]] process
    if (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') {
      // For node use HTTP adapter
      adapter = xhr;
    } else if (typeof XMLHttpRequest !== 'undefined') {
      // For browsers use XHR adapter
      adapter = xhr;
    }
    return adapter;
  }

  var defaults = {
    adapter: getDefaultAdapter(),

    transformRequest: [function transformRequest(data, headers) {
      normalizeHeaderName(headers, 'Accept');
      normalizeHeaderName(headers, 'Content-Type');
      if (utils.isFormData(data) ||
        utils.isArrayBuffer(data) ||
        utils.isBuffer(data) ||
        utils.isStream(data) ||
        utils.isFile(data) ||
        utils.isBlob(data)
      ) {
        return data;
      }
      if (utils.isArrayBufferView(data)) {
        return data.buffer;
      }
      if (utils.isURLSearchParams(data)) {
        setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
        return data.toString();
      }
      if (utils.isObject(data)) {
        setContentTypeIfUnset(headers, 'application/json;charset=utf-8');
        return JSON.stringify(data);
      }
      return data;
    }],

    transformResponse: [function transformResponse(data) {
      /*eslint no-param-reassign:0*/
      if (typeof data === 'string') {
        try {
          data = JSON.parse(data);
        } catch (e) { /* Ignore */ }
      }
      return data;
    }],

    /**
     * A timeout in milliseconds to abort a request. If set to 0 (default) a
     * timeout is not created.
     */
    timeout: 0,

    xsrfCookieName: 'XSRF-TOKEN',
    xsrfHeaderName: 'X-XSRF-TOKEN',

    maxContentLength: -1,

    validateStatus: function validateStatus(status) {
      return status >= 200 && status < 300;
    }
  };

  defaults.headers = {
    common: {
      'Accept': 'application/json, text/plain, */*'
    }
  };

  utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
    defaults.headers[method] = {};
  });

  utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
    defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
  });

  var defaults_1 = defaults;

  /**
   * Determines whether the specified URL is absolute
   *
   * @param {string} url The URL to test
   * @returns {boolean} True if the specified URL is absolute, otherwise false
   */
  var isAbsoluteURL = function isAbsoluteURL(url) {
    // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
    // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
    // by any combination of letters, digits, plus, period, or hyphen.
    return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
  };

  /**
   * Creates a new URL by combining the specified URLs
   *
   * @param {string} baseURL The base URL
   * @param {string} relativeURL The relative URL
   * @returns {string} The combined URL
   */
  var combineURLs = function combineURLs(baseURL, relativeURL) {
    return relativeURL
      ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '')
      : baseURL;
  };

  /**
   * Throws a `Cancel` if cancellation has been requested.
   */
  function throwIfCancellationRequested(config) {
    if (config.cancelToken) {
      config.cancelToken.throwIfRequested();
    }
  }

  /**
   * Dispatch a request to the server using the configured adapter.
   *
   * @param {object} config The config that is to be used for the request
   * @returns {Promise} The Promise to be fulfilled
   */
  var dispatchRequest = function dispatchRequest(config) {
    throwIfCancellationRequested(config);

    // Support baseURL config
    if (config.baseURL && !isAbsoluteURL(config.url)) {
      config.url = combineURLs(config.baseURL, config.url);
    }

    // Ensure headers exist
    config.headers = config.headers || {};

    // Transform request data
    config.data = transformData(
      config.data,
      config.headers,
      config.transformRequest
    );

    // Flatten headers
    config.headers = utils.merge(
      config.headers.common || {},
      config.headers[config.method] || {},
      config.headers || {}
    );

    utils.forEach(
      ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
      function cleanHeaderConfig(method) {
        delete config.headers[method];
      }
    );

    var adapter = config.adapter || defaults_1.adapter;

    return adapter(config).then(function onAdapterResolution(response) {
      throwIfCancellationRequested(config);

      // Transform response data
      response.data = transformData(
        response.data,
        response.headers,
        config.transformResponse
      );

      return response;
    }, function onAdapterRejection(reason) {
      if (!isCancel(reason)) {
        throwIfCancellationRequested(config);

        // Transform response data
        if (reason && reason.response) {
          reason.response.data = transformData(
            reason.response.data,
            reason.response.headers,
            config.transformResponse
          );
        }
      }

      return Promise.reject(reason);
    });
  };

  /**
   * Config-specific merge-function which creates a new config-object
   * by merging two configuration objects together.
   *
   * @param {Object} config1
   * @param {Object} config2
   * @returns {Object} New object resulting from merging config2 to config1
   */
  var mergeConfig = function mergeConfig(config1, config2) {
    // eslint-disable-next-line no-param-reassign
    config2 = config2 || {};
    var config = {};

    utils.forEach(['url', 'method', 'params', 'data'], function valueFromConfig2(prop) {
      if (typeof config2[prop] !== 'undefined') {
        config[prop] = config2[prop];
      }
    });

    utils.forEach(['headers', 'auth', 'proxy'], function mergeDeepProperties(prop) {
      if (utils.isObject(config2[prop])) {
        config[prop] = utils.deepMerge(config1[prop], config2[prop]);
      } else if (typeof config2[prop] !== 'undefined') {
        config[prop] = config2[prop];
      } else if (utils.isObject(config1[prop])) {
        config[prop] = utils.deepMerge(config1[prop]);
      } else if (typeof config1[prop] !== 'undefined') {
        config[prop] = config1[prop];
      }
    });

    utils.forEach([
      'baseURL', 'transformRequest', 'transformResponse', 'paramsSerializer',
      'timeout', 'withCredentials', 'adapter', 'responseType', 'xsrfCookieName',
      'xsrfHeaderName', 'onUploadProgress', 'onDownloadProgress', 'maxContentLength',
      'validateStatus', 'maxRedirects', 'httpAgent', 'httpsAgent', 'cancelToken',
      'socketPath'
    ], function defaultToConfig2(prop) {
      if (typeof config2[prop] !== 'undefined') {
        config[prop] = config2[prop];
      } else if (typeof config1[prop] !== 'undefined') {
        config[prop] = config1[prop];
      }
    });

    return config;
  };

  /**
   * Create a new instance of Axios
   *
   * @param {Object} instanceConfig The default config for the instance
   */
  function Axios(instanceConfig) {
    this.defaults = instanceConfig;
    this.interceptors = {
      request: new InterceptorManager_1(),
      response: new InterceptorManager_1()
    };
  }

  /**
   * Dispatch a request
   *
   * @param {Object} config The config specific for this request (merged with this.defaults)
   */
  Axios.prototype.request = function request(config) {
    /*eslint no-param-reassign:0*/
    // Allow for axios('example/url'[, config]) a la fetch API
    if (typeof config === 'string') {
      config = arguments[1] || {};
      config.url = arguments[0];
    } else {
      config = config || {};
    }

    config = mergeConfig(this.defaults, config);
    config.method = config.method ? config.method.toLowerCase() : 'get';

    // Hook up interceptors middleware
    var chain = [dispatchRequest, undefined];
    var promise = Promise.resolve(config);

    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
      chain.unshift(interceptor.fulfilled, interceptor.rejected);
    });

    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
      chain.push(interceptor.fulfilled, interceptor.rejected);
    });

    while (chain.length) {
      promise = promise.then(chain.shift(), chain.shift());
    }

    return promise;
  };

  Axios.prototype.getUri = function getUri(config) {
    config = mergeConfig(this.defaults, config);
    return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\?/, '');
  };

  // Provide aliases for supported request methods
  utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
    /*eslint func-names:0*/
    Axios.prototype[method] = function(url, config) {
      return this.request(utils.merge(config || {}, {
        method: method,
        url: url
      }));
    };
  });

  utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
    /*eslint func-names:0*/
    Axios.prototype[method] = function(url, data, config) {
      return this.request(utils.merge(config || {}, {
        method: method,
        url: url,
        data: data
      }));
    };
  });

  var Axios_1 = Axios;

  /**
   * A `Cancel` is an object that is thrown when an operation is canceled.
   *
   * @class
   * @param {string=} message The message.
   */
  function Cancel(message) {
    this.message = message;
  }

  Cancel.prototype.toString = function toString() {
    return 'Cancel' + (this.message ? ': ' + this.message : '');
  };

  Cancel.prototype.__CANCEL__ = true;

  var Cancel_1 = Cancel;

  /**
   * A `CancelToken` is an object that can be used to request cancellation of an operation.
   *
   * @class
   * @param {Function} executor The executor function.
   */
  function CancelToken(executor) {
    if (typeof executor !== 'function') {
      throw new TypeError('executor must be a function.');
    }

    var resolvePromise;
    this.promise = new Promise(function promiseExecutor(resolve) {
      resolvePromise = resolve;
    });

    var token = this;
    executor(function cancel(message) {
      if (token.reason) {
        // Cancellation has already been requested
        return;
      }

      token.reason = new Cancel_1(message);
      resolvePromise(token.reason);
    });
  }

  /**
   * Throws a `Cancel` if cancellation has been requested.
   */
  CancelToken.prototype.throwIfRequested = function throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  };

  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  CancelToken.source = function source() {
    var cancel;
    var token = new CancelToken(function executor(c) {
      cancel = c;
    });
    return {
      token: token,
      cancel: cancel
    };
  };

  var CancelToken_1 = CancelToken;

  /**
   * Syntactic sugar for invoking a function and expanding an array for arguments.
   *
   * Common use case would be to use `Function.prototype.apply`.
   *
   *  ```js
   *  function f(x, y, z) {}
   *  var args = [1, 2, 3];
   *  f.apply(null, args);
   *  ```
   *
   * With `spread` this example can be re-written.
   *
   *  ```js
   *  spread(function(x, y, z) {})([1, 2, 3]);
   *  ```
   *
   * @param {Function} callback
   * @returns {Function}
   */
  var spread = function spread(callback) {
    return function wrap(arr) {
      return callback.apply(null, arr);
    };
  };

  /**
   * Create an instance of Axios
   *
   * @param {Object} defaultConfig The default config for the instance
   * @return {Axios} A new instance of Axios
   */
  function createInstance(defaultConfig) {
    var context = new Axios_1(defaultConfig);
    var instance = bind(Axios_1.prototype.request, context);

    // Copy axios.prototype to instance
    utils.extend(instance, Axios_1.prototype, context);

    // Copy context to instance
    utils.extend(instance, context);

    return instance;
  }

  // Create the default instance to be exported
  var axios = createInstance(defaults_1);

  // Expose Axios class to allow class inheritance
  axios.Axios = Axios_1;

  // Factory for creating new instances
  axios.create = function create(instanceConfig) {
    return createInstance(mergeConfig(axios.defaults, instanceConfig));
  };

  // Expose Cancel & CancelToken
  axios.Cancel = Cancel_1;
  axios.CancelToken = CancelToken_1;
  axios.isCancel = isCancel;

  // Expose all/spread
  axios.all = function all(promises) {
    return Promise.all(promises);
  };
  axios.spread = spread;

  var axios_1 = axios;

  // Allow use of default import syntax in TypeScript
  var default_1 = axios;
  axios_1.default = default_1;

  var axios$1 = axios_1;

  function get(token, url, options) {
      return axios$1.get(addTokenParam(token, url), options);
  }
  function post(token, url, body, options) {
      return axios$1.post(addTokenParam(token, url), body, options);
  }
  function doDelete(token, url, options) {
      return axios$1.delete(addTokenParam(token, url), options);
  }
  function addTokenParam(token, url) {
      return "" + url + (url.includes("?") ? "&" : "?") + "circle-token=" + token;
  }
  /**
   * Create a client for interacting with the CircleCI API.
   *
   * @param token CircleCI API token
   * @param circleHost Custom host address for CircleCI
   */
  function client(token, circleHost) {
      var _this = this;
      if (circleHost === void 0) { circleHost = API_BASE; }
      var baseOptions = { baseURL: circleHost };
      var factory = {
          get: function (url, options) {
              if (options === void 0) { options = {}; }
              return __awaiter(_this, void 0, void 0, function () {
                  return __generator(this, function (_a) {
                      switch (_a.label) {
                          case 0: return [4 /*yield*/, get(token, url, __assign({}, baseOptions, options))];
                          case 1: return [2 /*return*/, (_a.sent()).data];
                      }
                  });
              });
          },
          post: function (url, body, options) {
              if (options === void 0) { options = {}; }
              return __awaiter(_this, void 0, void 0, function () {
                  return __generator(this, function (_a) {
                      switch (_a.label) {
                          case 0: return [4 /*yield*/, post(token, url, body, __assign({}, baseOptions, options))];
                          case 1: return [2 /*return*/, (_a.sent()).data];
                      }
                  });
              });
          },
          delete: function (url, options) {
              if (options === void 0) { options = {}; }
              return __awaiter(_this, void 0, void 0, function () {
                  return __generator(this, function (_a) {
                      switch (_a.label) {
                          case 0: return [4 /*yield*/, doDelete(token, url, __assign({}, baseOptions, options))];
                          case 1: return [2 /*return*/, (_a.sent())
                                  .data];
                      }
                  });
              });
          }
      };
      return factory;
  }

  /**
   * Commit a build action, returns a summary of the new build.
   *
   * Retry a build
   * @see https://circleci.com/docs/api/v1-reference/#retry-build
   * @example POST - /project/:vcs-type/:username/:project/:build_num/retry
   *
   * Cancel a build
   * @see https://circleci.com/docs/api/v1-reference/#cancel-build
   * @example POST - /project/:vcs-type/:username/:project/:build_num/cancel
   *
   * @param token - CircleCI API token
   * @param buildNumber - Target build number to retry
   * @param action - Action to perform on the build
   * @param circleHost Provide custom url for CircleCI
   * @param vcs - Project's git information that you'd like to retry
   */
  function postBuildActions(token, buildNumber, action, _a) {
      var circleHost = _a.circleHost, vcs = __rest(_a, ["circleHost"]);
      var url = createVcsUrl(vcs) + "/" + buildNumber + "/" + action;
      return client(token, circleHost).post(url);
  }
  /**
   * Triggers a new build, returns a summary of the build.
   * @see https://circleci.com/docs/api/v1-reference/#new-build
   * @example /project/:vcs-type/:username/:project
   *
   * Triggers a new build, returns a summary of the build.
   * @see https://circleci.com/docs/api/v1-reference/#new-build-branch
   * @example /project/:vcs-type/:username/:project/tree/:branch
   */
  function postTriggerNewBuild(token, _a) {
      var circleHost = _a.circleHost, vcs = _a.vcs, _b = _a.options, _c = _b === void 0 ? {} : _b, _d = _c.branch, branch = _d === void 0 ? "" : _d, _e = _c.newBuildOptions, newBuildOptions = _e === void 0 ? {} : _e;
      var url = "" + createVcsUrl(vcs) + (branch ? "/tree/" + branch : "");
      return client(token, circleHost).post(url, newBuildOptions);
  }

  /**
   * Validate a Request object for endpoints that require
   * certain information
   * @param token - CircleCI API token
   * @param type - Git type
   * @param owner - Repository owner
   * @param repo - Target repository
   * @throws If options passed in are not valid
   */
  function validateVCSRequest(_a) {
      var token = _a.token, _b = _a.vcs, type = _b.type, owner = _b.owner, repo = _b.repo;
      if (!token) {
          throw new Error("CircleCiApi - No token was provided");
      }
      var missing = [];
      if (!type) {
          missing.push("type");
      }
      if (!owner) {
          missing.push("owner");
      }
      if (!repo) {
          missing.push("repo");
      }
      if (missing.length) {
          throw new Error("CircleCiApi - Missing options " + missing);
      }
  }
  /**
   * Take a Options object and map it to query parameters
   * @example { limit: 5, branch: "develop" } => /builds?branch=develop&limit=5
   * @param opts - Query param object, branch is defaulted to master
   * @param ignoreBranch - Ignore the 'branch' option
   * @returns A string containing url encoded query params
   */
  function queryParams(opts) {
      if (opts === void 0) { opts = {}; }
      var params = Object.keys(opts)
          .filter(function (key) { return typeof opts[key] !== "undefined" && opts[key] !== null; })
          .reduce(function (prev, key, arr) { return prev.concat([
          key + "=" + encodeURIComponent(opts[key])
      ]); }, [])
          .join("&");
      return params.length ? "?" + params : "";
  }
  /**
   * Takes a string and will return the matching type, or
   * default to GitType.GITHUB
   * @default GitType.GITHUB
   * @see GitType
   * @param type - Raw string type
   */
  function getGitType(type) {
      var formatted = type
          .trim()
          .replace(/ /g, "")
          .toLowerCase();
      if (formatted === exports.GitType.BITBUCKET) {
          return formatted;
      }
      return exports.GitType.GITHUB;
  }
  /**
   * Create JSON headers for Axios
   */
  function createJsonHeader() {
      return {
          headers: {
              "Content-Type": "application/json",
              Accepts: "application/json"
          }
      };
  }

  /**
   * Get artifacts for single project build
   *
   * @see https://circleci.com/docs/api/v1-reference/#build-artifacts
   * @example /project/:vcs-type/:username/:project/:build_num/artifacts
   *
   * @param token - CircleCI API token
   * @param buildNumber - Target build number
   * @param circleHost Provide custom url for CircleCI
   * @param vcs - Project's git information
   * @returns Promise of an array of build artifacs
   */
  function getBuildArtifacts(token, buildNumber, _a) {
      var circleHost = _a.circleHost, vcs = __rest(_a, ["circleHost"]);
      var url = createVcsUrl(vcs) + "/" + buildNumber + "/artifacts";
      return client(token, circleHost).get(url);
  }
  /**
   * Get the latest build artifacts for a project
   *
   * @example branch - The branch you would like to look in for the latest build. Returns artifacts for latest build in entire project if omitted.
   * @example filter - Restricts which builds are returned. Set to "completed", "successful", "failed", "running"
   *
   * @see https://circleci.com/docs/api/v1-reference/#build-artifacts-latest
   * @example GET - /project/:vcs-type/:username/:project/latest/artifacts?branch=:branch&filter=:filter
   * @param token - CircleCI API token
   * @param vcs - Project's git information
   * @param options - Query parameters
   * @param circleHost Provide custom url for CircleCI
   */
  function getLatestArtifacts(token, _a) {
      var vcs = _a.vcs, _b = _a.options, options = _b === void 0 ? {} : _b, circleHost = _a.circleHost;
      var branch = options.branch, filter = options.filter;
      var url = createVcsUrl(vcs) + "/latest/artifacts" + queryParams({
          branch: branch,
          filter: filter
      });
      return client(token, circleHost).get(url);
  }

  /**
   * Get all recent builds for CircleCI user
   *
   * @see https://circleci.com/docs/api/v1-reference/#recent-builds
   * @example GET - /recent-builds?limit=10&offset=5
   *
   * @param token - CircleCI API token
   * @param limit - optional - Limit the number of builds returned, max=100
   * @param offset - optional -builds starting from this offset
   * @param circleHost Provide custom url for CircleCI
   * @returns List of recent build summaries
   */
  function getRecentBuilds(token, _a) {
      var _b = _a === void 0 ? {} : _a, limit = _b.limit, offset = _b.offset, circleHost = _b.circleHost;
      var url = "" + API_RECENT_BUILDS + queryParams({ limit: limit, offset: offset });
      return client(token, circleHost).get(url);
  }
  /**
   * Get recent build summaries for a project
   *
   * Supported query parameters:
   *
   * @example limit - The number of builds to return. Maximum 100, defaults to 30.
   * @example offset - builds starting from this offset, defaults to 0.
   * @example filter -Restricts which builds are returned. Set to "completed", "successful", "failed", "running"
   *
   * @see https://circleci.com/docs/api/v1-reference/#recent-builds-project
   * @example GET - /project/:vcs-type/:username/:project?circle-token=:token&limit=20&offset=5&filter=completed
   *
   * Get recent builds for a project and branch
   * @see https://circleci.com/docs/api/v1-reference/#recent-builds-project-branch
   * @example GET - /project/:vcs-type/:username/:project/tree/:branch
   *
   * @see FullRequest
   * @param token - CircleCI API token
   * @param vcs - Get builds for this project
   * @param options - Optional - Query parameters
   * @param circleHost Provide custom url for CircleCI
   * @returns A list of build summaries
   */
  function getBuildSummaries(token, _a) {
      var vcs = _a.vcs, _b = _a.options, options = _b === void 0 ? {} : _b, circleHost = _a.circleHost;
      var limit = options.limit, offset = options.offset, filter = options.filter, branch = options.branch;
      var url = "" + createVcsUrl(vcs) + (branch ? "/tree/" + branch : "");
      var params = queryParams({ limit: limit, offset: offset, filter: filter });
      return client(token, circleHost).get("" + url + params);
  }
  /**
   * Get full build details for a single build
   *
   * @see https://circleci.com/docs/api/v1-reference/#build
   * @example /project/:vcs-type/:username/:project/:build_num
   *
   * @param token - CircleCI API token
   * @param buildNumber - Target build number
   * @param circleHost Provide custom url for CircleCI
   * @param vcs - Project's git information
   * @returns Full build details including build steps
   */
  function getFullBuild(token, buildNumber, _a) {
      var circleHost = _a.circleHost, vcs = __rest(_a, ["circleHost"]);
      var url = createVcsUrl(vcs) + "/" + buildNumber;
      return client(token, circleHost).get(url);
  }

  /**
   * All followed projects:
   * @see https://circleci.com/docs/api/v1-reference/#projects
   * @example GET - /projects
   */
  function getAllProjects(token, _a) {
      var circleHost = (_a === void 0 ? {} : _a).circleHost;
      return client(token, circleHost).get(API_ALL_PROJECTS);
  }
  /**
   * Follow a new project. CircleCI will then monitor the project for automatic building of commits.
   * @see https://circleci.com/docs/api/v1-reference/#follow-project
   * @example POST - /project/:vcs-type/:username/:project/follow
   */
  function postFollowNewProject(token, _a) {
      var vcs = _a.vcs, circleHost = _a.circleHost;
      var url = createVcsUrl(vcs) + "/follow";
      return client(token, circleHost).post(url);
  }

  /**
   * Clear project cache
   *
   * @see https://circleci.com/docs/api/v1-reference/#clear-cache
   * @example DELETE : https://circleci.com/api/v1.1/project/:vcs-type/:username/:project/build-cache
   *
   * @param token CircleCI API token
   * @param circleHost Provide custom url for CircleCI
   * @param vcs Git info for project
   * @returns status message of request
   */
  function clearCache(token, _a) {
      var circleHost = _a.circleHost, vcs = __rest(_a, ["circleHost"]);
      var url = createVcsUrl(vcs) + "/build-cache";
      return client(token, circleHost).delete(url);
  }

  /**
   * Lists the checkout keys for a project
   *
   * @see https://circleci.com/docs/api/v1-reference/#list-checkout-keys
   * @example GET : https://circleci.com/api/v1.1/project/:vcs-type/:username/:project/checkout-key
   *
   * @param token CircleCI API token
   * @param circleHost Provide custom url for CircleCI
   * @param vcs Git information for project
   * @returns list of checkout keys for a specific project
   */
  function getCheckoutKeys(token, _a) {
      var circleHost = _a.circleHost, vcs = __rest(_a, ["circleHost"]);
      return client(token, circleHost).get(createUrl(vcs));
  }
  /**
   * Create a checkout key for a project
   *
   * @see https://circleci.com/docs/api/v1-reference/#new-checkout-key
   * @example POST : https://circleci.com/api/v1.1/project/:vcs-type/:username/:project/checkout-key
   *
   * @param token CircleCI API token
   * @param key Key to create for project
   * @param vcs Git information for project
   * @param circleHost Provide custom url for CircleCI
   * @returns New checkout key
   */
  function createCheckoutKey(token, key, _a) {
      var circleHost = _a.circleHost, vcs = __rest(_a, ["circleHost"]);
      return client(token, circleHost).post(createUrl(vcs), key, createJsonHeader());
  }
  /**
   * Get a single checkout key from it's fingerprint
   *
   * @see https://circleci.com/docs/api/v1-reference/#get-checkout-key
   * @example POST : https://circleci.com/api/v1.1/project/:vcs-type/:username/:project/checkout-key
   *
   * @param token CircleCI API token
   * @param fingerprint Fingerprint of the key to fetch
   * @param circleHost Provide custom url for CircleCI
   * @param vcs Git information for project
   * @returns list of checkout keys for a specific project
   */
  function getCheckoutKey(token, fingerprint, _a) {
      var circleHost = _a.circleHost, vcs = __rest(_a, ["circleHost"]);
      return client(token, circleHost).get(createUrl(vcs, fingerprint));
  }
  /**
   * Deletes a checkout key
   *
   * @see https://circleci.com/docs/api/v1-reference/#delete-checkout-key
   * @example DELETE : https://circleci.com/api/v1.1/project/:vcs-type/:username/:project/checkout-key/:fingerprint
   *
   * @param token CircleCI API token
   * @param fingerprint Fingerprint of the key to delete
   * @param circleHost Provide custom url for CircleCI
   * @param vcs Git information for project
   * @returns Status message of deletion
   */
  function deleteCheckoutKey(token, fingerprint, _a) {
      var circleHost = _a.circleHost, vcs = __rest(_a, ["circleHost"]);
      return client(token, circleHost).delete(createUrl(vcs, fingerprint));
  }
  /**
   * Create a url for checkout-key operations
   * @private
   * @param vcs Git information for project
   * @param name Optional, Name of the environment variable
   */
  function createUrl(vcs, fingerprint) {
      return createVcsUrl(vcs) + "/checkout-key" + (fingerprint ? "/" + fingerprint : "");
  }

  /**
   * List all of a projects environment variables, part of the
   * value will be masked with *'s
   *
   * @see getEnv for retrieving the hidden value of an env variable
   *
   * @see https://circleci.com/docs/api/v1-reference/#list-environment-variables
   * @example GET : https://circleci.com/api/v1.1/project/:vcs-type/:username/:project/envvar
   *
   * @param token CircleCI API token
   * @param circleHost Provide custom url for CircleCI
   * @param vcs Git information for project
   * @returns list of env variables for a specific project
   */
  function listEnv(token, _a) {
      var circleHost = _a.circleHost, vcs = __rest(_a, ["circleHost"]);
      return client(token, circleHost).get(createUrl$1(vcs));
  }
  /**
   * Add environment variable to project
   *
   * @see https://circleci.com/docs/api/v1-reference/#add-environment-variable
   * @example POST : https://circleci.com/api/v1.1/project/:vcs-type/:username/:project/envvar
   *
   * @param token CircleCI API token
   * @param payload Environment variable object to add to project
   * @param vcs Git information for project
   * @param circleHost Provide custom url for CircleCI
   * @returns newly created environment variable
   */
  function addEnv(token, payload, _a) {
      var circleHost = _a.circleHost, vcs = __rest(_a, ["circleHost"]);
      return client(token, circleHost).post(createUrl$1(vcs), payload, createJsonHeader());
  }
  /**
   * Gets the hidden value of environment variable :name
   *
   * @example GET : https://circleci.com/api/v1.1/project/:vcs-type/:username/:project/envvar/:name
   * @see https://circleci.com/docs/api/v1-reference/#get-environment-variable
   *
   * @param token CircleCI API token
   * @param envName Name of variable to fetch value
   * @param circleHost Provide custom url for CircleCI
   * @param vcs Git information for project
   * @returns Full hidden value of environment variable
   */
  function getEnv(token, envName, _a) {
      var circleHost = _a.circleHost, vcs = __rest(_a, ["circleHost"]);
      return client(token, circleHost).get(createUrl$1(vcs, envName));
  }
  /**
   * Deletes the environment variable named ':name'
   *
   * @example DELETE : https://circleci.com/api/v1.1/project/:vcs-type/:username/:project/envvar/:name
   * @see https://circleci.com/docs/api/v1-reference/#delete-environment-variable
   *
   * @param token CircleCI API token
   * @param envName Name of variable to fetch value
   * @param circleHost Provide custom url for CircleCI
   * @param vcs Git information for project
   * @returns Status message result of operation
   */
  function deleteEnv(token, envName, _a) {
      var circleHost = _a.circleHost, vcs = __rest(_a, ["circleHost"]);
      return client(token, circleHost).delete(createUrl$1(vcs, envName));
  }
  /**
   * Create a url for env operations
   * @private
   * @param vcs Git information for project
   * @param name Optional, Name of the environment variable
   */
  function createUrl$1(vcs, name) {
      if (name === void 0) { name = ""; }
      return createVcsUrl(vcs) + "/envvar" + (name ? "/" + name : "");
  }

  /**
   * Provides test metadata for a build
   *
   * @see https://circleci.com/docs/api/v1-reference/#test-metadata
   * @example GET : https://circleci.com/api/v1.1/project/:vcs-type/:username/:project/:build_num/tests
   *
   * @param token CircleCI API token
   * @param buildNumber Build number to get metadata for
   * @param circleHost Provide custom url for CircleCI
   * @param vcs Git information for project
   * @returns metadata for tests
   */
  function getTestMetadata(token, buildNumber, _a) {
      var circleHost = _a.circleHost, vcs = __rest(_a, ["circleHost"]);
      var url = createVcsUrl(vcs) + "/" + buildNumber + "/tests";
      return client(token, circleHost).get(url);
  }

  /**
   * Creates an ssh key that will be used to access the external system identified by
   * the hostname parameter for SSH key-based authentication.
   *
   * @see https://circleci.com/docs/api/v1-reference/#ssh-keys
   * @example POST - https://circleci.com/api/v1.1/project/:vcs-type/:username/:project/ssh-key
   *
   * @param token CircleCI API token
   * @param vcs Git information for project
   * @param key SSH key details to add to project
   * @param circleHost Provide custom url for CircleCI
   * @returns nothing unless error
   */
  function addSSHKey(token, vcs, key, _a) {
      var circleHost = (_a === void 0 ? {} : _a).circleHost;
      var url = createVcsUrl(vcs) + "/ssh-key";
      return client(token, circleHost).post(url, key);
  }
  /**
   * Adds your Heroku API key to CircleCI
   *
   * @see https://circleci.com/docs/api/v1-reference/#ssh-keys
   * @example POST - https://circleci.com/api/v1.1/project/:vcs-type/:username/:project/ssh-key
   *
   * @param token CircleCI API token
   * @param key Heroku key to add to project
   * @param circleHost Provide custom url for CircleCI
   * @returns nothing unless error
   */
  function addHerokuKey(token, key, _a) {
      var circleHost = (_a === void 0 ? {} : _a).circleHost;
      var url = API_USER + "/heroku-key";
      return client(token, circleHost).post(url, key);
  }

  /**
   * Get authenticated user
   * @see https://circleci.com/docs/api/v1-reference/#getting-started
   * @example GET - /me
   */
  function getMe(token, _a) {
      var circleHost = (_a === void 0 ? {} : _a).circleHost;
      return client(token, circleHost).get(API_ME);
  }

  // TODO
  /*
    For the endpoints that accept filters/offset/etc
    modify factory functions to pass in only required options
  */
  /**
   * CircleCI API Wrapper
   * A wrapper for all of the circleci api calls.
   * Most values can be overridden by individual methods
   *
   */
  var CircleCI = /** @class */ (function () {
      /**
       *
       * @param token CircleCI API token
       * @param vcs Default git information
       * @param vcs.type Git project type ex "github" | "bitbucket"
       * @param vcs.owner Owner of the git repository
       * @param vcs.repo Git repository name
       * @param options Additional query parameters
       * @returns {CircleCI} wrapper for CircleCI
       */
      function CircleCI(_a) {
          var token = _a.token, _b = _a.vcs, _c = _b === void 0 ? {} : _b, _d = _c.type, type = _d === void 0 ? exports.GitType.GITHUB : _d, _e = _c.owner, owner = _e === void 0 ? "" : _e, _f = _c.repo, repo = _f === void 0 ? "" : _f, _g = _a.options, options = _g === void 0 ? {} : _g, circleHost = _a.circleHost;
          this.token = token;
          this.vcs = { type: type, owner: owner, repo: repo };
          this.options = options;
          this.circleOptions = { circleHost: circleHost };
      }
      /**
       * Get the options used to create this instance
       */
      CircleCI.prototype.defaults = function () {
          return { token: this.token, vcs: this.vcs, options: this.options };
      };
      /**
       * Adds the CircleCI token to a url
       * @param url URL to modify
       */
      CircleCI.prototype.addToken = function (url) {
          return url + "?circle-token=" + this.token;
      };
      /**
       * Get the currently authenticated user
       */
      CircleCI.prototype.me = function () {
          return getMe(this.token, this.circleOptions);
      };
      /**
       * Get a list of all the projects the user follows
       */
      CircleCI.prototype.projects = function () {
          return getAllProjects(this.token, this.circleOptions);
      };
      /**
       * Follow a new project. CircleCI will then monitor the project for automatic building of commits.
       * @param opts Project information
       */
      CircleCI.prototype.followProject = function (opts) {
          var _a = this.createRequest(opts), token = _a.token, rest = __rest(_a, ["token"]);
          return postFollowNewProject(token, __assign({}, rest, this.circleOptions));
      };
      /**
       * Get all recent builds for CircleCI user
       * @param reqOptions Optional, Request options
       * @param reqOptions.options.limit Optional, Limit the number of builds returned, max=100
       * @param reqOptions.options.offset Optional, builds starting from this offset
       * @param opts Optional settings
       */
      CircleCI.prototype.recentBuilds = function (reqOptions, opts) {
          if (reqOptions === void 0) { reqOptions = {}; }
          var _a = this.createRequest(__assign({}, (opts || {}), { options: __assign({}, (opts ? opts.options : {}), reqOptions) })), token = _a.token, options = _a.options;
          return getRecentBuilds(token, __assign({}, options, this.circleOptions));
      };
      /**
       * Get recent build summaries for a project
       * @param reqOptions Optional, request options for filtering, limiting, etc
       * @param reqOptions.limit Optional, the number of builds to return. Maximum 100, defaults to 30.
       * @param reqOptions.offset Optional, builds starting from this offset, defaults to 0.
       * @param reqOptions.filter Optional, restricts which builds are returned. Set to "completed", "successful", "failed", "running"
       * @param opts Optional settings
       */
      CircleCI.prototype.builds = function (reqOptions, opts) {
          var _a = this.createRequest(__assign({}, (opts || {}), { options: __assign({}, (opts ? opts.options : {}), (reqOptions || {})) })), token = _a.token, rest = __rest(_a, ["token"]);
          return getBuildSummaries(token, __assign({}, rest, this.circleOptions));
      };
      /**
       * Get recent builds for a project and branch
       * @param branch Target branch to fetch builds for
       * @param reqOptions Optional, request options for filtering, limiting, etc
       * @param reqOptions.limit Optional, the number of builds to return. Maximum 100, defaults to 30.
       * @param reqOptions.offset Optional, builds starting from this offset, defaults to 0.
       * @param reqOptions.filter Optional, restricts which builds are returned. Set to "completed", "successful", "failed", "running"
       * @param opts Optional settings
       */
      CircleCI.prototype.buildsFor = function (branch, reqOptions, opts) {
          if (branch === void 0) { branch = "master"; }
          if (reqOptions === void 0) { reqOptions = {}; }
          var _a = this.createRequest(__assign({}, opts, { options: __assign({}, (opts ? opts.options : {}), reqOptions, { branch: branch }) })), token = _a.token, rest = __rest(_a, ["token"]);
          return getBuildSummaries(token, __assign({}, rest, this.circleOptions));
      };
      /**
       * Get full build details for a single build
       * @param buildNumber Target build number
       * @param opts Optional settings
       */
      CircleCI.prototype.build = function (buildNumber, opts) {
          var _a = this.createRequest(__assign({}, (opts || {}), { options: __assign({}, (opts ? opts.options : {})) })), token = _a.token, vcs = _a.vcs;
          return getFullBuild(token, buildNumber, __assign({}, vcs, this.circleOptions));
      };
      /**
       * Get artifacts for single project build
       * @param buildNumber Target build number
       * @param opts Optional settings to override class defaults
       */
      CircleCI.prototype.artifacts = function (buildNumber, opts) {
          var _a = this.createRequest(opts), token = _a.token, vcs = _a.vcs;
          return getBuildArtifacts(token, buildNumber, __assign({}, vcs, this.circleOptions));
      };
      /**
       * Get the latest build artifacts for a project
       * Pass a branch in the options to target a specific branch
       * @param reqOptions Optional, request options for filtering and specifying a branch
       * @param reqOptions.branch The branch you would like to look in for the latest build. Returns artifacts for latest build in entire project if omitted.
       * @param reqOptions.filter Restricts which builds are returned. Set to "completed", "successful", "failed", "running"
       * @param opts Optional settings
       */
      CircleCI.prototype.latestArtifacts = function (reqOptions, opts) {
          if (opts === void 0) { opts = {}; }
          var _a = this.createRequest(__assign({}, opts, { options: __assign({}, opts.options, (reqOptions || {})) })), token = _a.token, rest = __rest(_a, ["token"]);
          return getLatestArtifacts(token, __assign({}, rest, this.circleOptions));
      };
      /**
       * Retries the build, returns a summary of the new build.
       * @param build Target build number
       * @param opts Optional settings
       */
      CircleCI.prototype.retry = function (build, opts) {
          return this.performAction(__assign({}, this.createRequest(opts), this.circleOptions), build, exports.BuildAction.RETRY);
      };
      /**
       * Cancels the build, returns a summary of the new build.
       * @param build Target build number
       * @param opts Optional settings
       */
      CircleCI.prototype.cancel = function (build, opts) {
          return this.performAction(__assign({}, this.createRequest(opts), this.circleOptions), build, exports.BuildAction.CANCEL);
      };
      /**
       * Triggers a new build, returns a summary of the build.
       * @see https://circleci.com/docs/api/v1-reference/#new-build
       * @param opts Optional settings
       * @param opts.options.newBuildOptions Additional build settings
       */
      CircleCI.prototype.triggerBuild = function (opts) {
          var _a = this.createRequest(opts), token = _a.token, rest = __rest(_a, ["token"]);
          return postTriggerNewBuild(token, __assign({}, rest, this.circleOptions));
      };
      /**
       * Triggers a new build for a specific branch.
       * @see https://circleci.com/docs/api/v1-reference/#new-build-branch
       * @param branch Optional, branch to target, defaults to 'master'
       * @param opts Optional settings
       * @param opts.options.newBuildOptions Additional build settings
       */
      CircleCI.prototype.triggerBuildFor = function (branch, opts) {
          if (branch === void 0) { branch = "master"; }
          var _a = this.createRequest(__assign({}, opts, { options: __assign({}, (opts ? opts.options : {}), { branch: branch }) })), token = _a.token, request = __rest(_a, ["token"]);
          return postTriggerNewBuild(token, __assign({}, request, this.circleOptions));
      };
      /*
       * Cache
       */
      /**
       * Clear the cache for the project
       * @see clearCache for implementation
       * @see https://circleci.com/docs/api/v1-reference/#clear-cache
       * @param opts Optional settings
       */
      CircleCI.prototype.clearCache = function (opts) {
          var _a = this.createRequest(opts), token = _a.token, vcs = _a.vcs;
          return clearCache(token, __assign({}, vcs, this.circleOptions));
      };
      /*
       * Environment Variables
       */
      /**
       * List all of a projects environment variables, values will not be fully shown
       * @see getEnvVar for accessing full value
       * @see listEnv
       * @see https://circleci.com/docs/api/v1-reference/#list-environment-variables
       * @param opts Optional settings
       */
      CircleCI.prototype.listEnvVars = function (opts) {
          var _a = this.createRequest(opts), token = _a.token, vcs = _a.vcs;
          return listEnv(token, __assign({}, vcs, this.circleOptions));
      };
      /**
       * Add environment variable to project
       * @see addEnv
       * @see https://circleci.com/docs/api/v1-reference/#add-environment-variable
       * @param variable Environment variable to add to project
       * @param opts Optional settings
       */
      CircleCI.prototype.addEnvVar = function (variable, opts) {
          var _a = this.createRequest(opts), token = _a.token, vcs = _a.vcs;
          return addEnv(token, variable, __assign({}, vcs, this.circleOptions));
      };
      /**
       * Get the hidden value of an environment variable
       * @see getEnv
       * @see https://circleci.com/docs/api/v1-reference/#get-environment-variable
       * @param envName Name of the variable to fetch
       * @param opts Optional settings
       */
      CircleCI.prototype.getEnvVar = function (envName, opts) {
          var _a = this.createRequest(opts), token = _a.token, vcs = _a.vcs;
          return getEnv(token, envName, __assign({}, vcs, this.circleOptions));
      };
      /**
       * Delete an environment variable
       * @see deleteEnv
       * @see https://circleci.com/docs/api/v1-reference/#delete-environment-variable
       * @param envName Name of the variable to delete
       * @param opts Optional settings
       */
      CircleCI.prototype.deleteEnvVar = function (envName, opts) {
          var _a = this.createRequest(opts), token = _a.token, vcs = _a.vcs;
          return deleteEnv(token, envName, __assign({}, vcs, this.circleOptions));
      };
      /*
       * Checkout Keys
       */
      /**
       * List all the checkout keys for the project
       * @see getCheckoutKeys
       * @see https://circleci.com/docs/api/v1-reference/#list-checkout-keys
       * @param opts Optional request settings
       */
      CircleCI.prototype.listCheckoutKeys = function (opts) {
          var _a = this.createRequest(opts), token = _a.token, vcs = _a.vcs;
          return getCheckoutKeys(token, __assign({}, vcs, this.circleOptions));
      };
      /**
       * Create a new checkout key
       * @see createCheckoutKey
       * @see https://circleci.com/docs/api/v1-reference/#new-checkout-key
       * @param type Type of checkout key to create
       * @param opts Optional request settings
       */
      CircleCI.prototype.addCheckoutKey = function (type, opts) {
          var _a = this.createRequest(opts), token = _a.token, vcs = _a.vcs;
          return createCheckoutKey(token, { type: type }, __assign({}, vcs, this.circleOptions));
      };
      /**
       * Get a single checkout key from it's fingerprint
       * @see getCheckoutKey
       * @see https://circleci.com/docs/api/v1-reference/#get-checkout-key
       * @param fingerprint Fingerprint of the key to get
       * @param opts Optional request settings
       */
      CircleCI.prototype.getCheckoutKey = function (fingerprint, opts) {
          var _a = this.createRequest(opts), token = _a.token, vcs = _a.vcs;
          return getCheckoutKey(token, fingerprint, __assign({}, vcs, this.circleOptions));
      };
      /**
       * Delete a checkout key
       * @see deleteCheckoutKey
       * @see https://circleci.com/docs/api/v1-reference/#delete-checkout-key
       * @param fingerprint Fingerprint of the key to delete
       * @param opts Optional request settings
       */
      CircleCI.prototype.deleteCheckoutKey = function (fingerprint, opts) {
          var _a = this.createRequest(opts), token = _a.token, vcs = _a.vcs;
          return deleteCheckoutKey(token, fingerprint, __assign({}, vcs, this.circleOptions));
      };
      /**
       * Get test metadata for a build
       * @see getTestMetadata
       * @see https://circleci.com/docs/api/v1-reference/#test-metadata
       * @param buildNumber Build number to get metadata for
       * @param opts Optional request settings
       */
      CircleCI.prototype.getTestMetadata = function (buildNumber, opts) {
          var _a = this.createRequest(opts), token = _a.token, vcs = _a.vcs;
          return getTestMetadata(token, buildNumber, __assign({}, vcs, this.circleOptions));
      };
      /**
       * Creates an ssh key that will be used to access the external system identified by
       * the hostname parameter for SSH key-based authentication.
       * @see https://circleci.com/docs/api/v1-reference/#ssh-keys
       * @param token CircleCI API token
       * @param vcs Git information for project
       * @param key SSH key details to add to project
       */
      CircleCI.prototype.addSSHKey = function (key, opts) {
          var _a = this.createRequest(opts), token = _a.token, vcs = _a.vcs;
          return addSSHKey(token, vcs, key, this.circleOptions);
      };
      /**
       * Adds your Heroku API key to CircleCI
       * @see https://circleci.com/docs/api/v1-reference/#ssh-keys
       * @param token CircleCI API token
       * @param key Heroku key to add to project
       */
      CircleCI.prototype.addHerokuKey = function (key, opts) {
          var token = this.createRequest(opts).token;
          return addHerokuKey(token, key, this.circleOptions);
      };
      /*
       * Private functions
       */
      /**
       * Take a request object and merge it with the class properties.
       * Passed in options always take priority over the class properties
       * @param opts Optional, request options
       * @throws If missing a token, or VCS options
       * @returns Merged request object
       */
      CircleCI.prototype.createRequest = function (opts) {
          if (opts === void 0) { opts = {}; }
          var request = {
              token: opts.token || this.token,
              options: __assign({}, this.options, opts.options),
              vcs: __assign({}, this.vcs, opts.vcs)
          };
          validateVCSRequest(request);
          return request;
      };
      /**
       * Perform a build action on a build
       * @see BuildAction for list of actions
       * @see postBuildActions for implementation
       * @param request Request information
       * @param build Build number to perform action on
       * @param action Type of action to perform
       */
      CircleCI.prototype.performAction = function (request, build, action) {
          var token = request.token, vcs = request.vcs, circleHost = request.circleHost;
          return postBuildActions(token, build, action, __assign({}, vcs, { circleHost: circleHost }));
      };
      return CircleCI;
  }());

  exports.API_ALL_PROJECTS = API_ALL_PROJECTS;
  exports.API_BASE = API_BASE;
  exports.API_ME = API_ME;
  exports.API_PROJECT = API_PROJECT;
  exports.API_RECENT_BUILDS = API_RECENT_BUILDS;
  exports.API_USER = API_USER;
  exports.CircleCI = CircleCI;
  exports.addEnv = addEnv;
  exports.addHerokuKey = addHerokuKey;
  exports.addSSHKey = addSSHKey;
  exports.clearCache = clearCache;
  exports.createCheckoutKey = createCheckoutKey;
  exports.createVcsUrl = createVcsUrl;
  exports.deleteCheckoutKey = deleteCheckoutKey;
  exports.deleteEnv = deleteEnv;
  exports.getAllProjects = getAllProjects;
  exports.getBuildArtifacts = getBuildArtifacts;
  exports.getBuildSummaries = getBuildSummaries;
  exports.getCheckoutKey = getCheckoutKey;
  exports.getCheckoutKeys = getCheckoutKeys;
  exports.getEnv = getEnv;
  exports.getFullBuild = getFullBuild;
  exports.getGitType = getGitType;
  exports.getLatestArtifacts = getLatestArtifacts;
  exports.getMe = getMe;
  exports.getRecentBuilds = getRecentBuilds;
  exports.getTestMetadata = getTestMetadata;
  exports.listEnv = listEnv;
  exports.postBuildActions = postBuildActions;
  exports.postFollowNewProject = postFollowNewProject;
  exports.postTriggerNewBuild = postTriggerNewBuild;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=circleci-api.umd.js.map
